/******************************************************************************
*
* Copyright (C) 2009 - 2014 Xilinx, Inc.  All rights reserved.
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* Use of the Software is limited solely to applications:
* (a) running on a Xilinx device, or
* (b) that interact with a Xilinx device through a bus or interconnect.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
* XILINX  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
* OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*
* Except as contained in this notice, the name of the Xilinx shall not be used
* in advertising or otherwise to promote the sale, use or other dealings in
* this Software without prior written authorization from Xilinx.
*
******************************************************************************/

/*
 * helloworld.c: simple test application
 *
 * This application configures UART 16550 to baud rate 9600.
 * PS7 UART (Zynq) is not initialized by this application, since
 * bootrom/bsp configures it to baud rate 115200
 *
 * ------------------------------------------------
 * | UART TYPE   BAUD RATE                        |
 * ------------------------------------------------
 *   uartns550   9600
 *   uartlite    Configurable only in HW design
 *   ps7_uart    115200 (configured by bootrom/bsp)
 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "xparameters.h"
#include "platform.h"
#include "xil_printf.h"
#include "xgpio.h"
#include "xtmrctr.h"
#include "xil_types.h"

#define TIMER_ID XPAR_AXI_TIMER_0_DEVICE_ID
#define GPIO_ID XPAR_AXI_GPIO_0_DEVICE_ID
const unsigned int TTL_CHANNEL = 2; // channels depend on what was added first to GPIO in block design
const unsigned int LED_CHANNEL = 1;

/*
 * 16 IO pins, IO26 through IO41
 * IO41 currently used for interrupt input signal
 * Only 15 pins available for pattern
 */
const unsigned int ABORT_PIN = 0x8000;
const unsigned int TTL_IO = 0x8000; // bitwise or of all the input pins, have to do this by hand
const int PATTERN_LENGTH = 15; // have to do this by hand
const unsigned int ABORT_PATTERN = 0; // turn everything off, edit this later

const unsigned int MAX_TICKS0 = -1; // underflows to UINT32_MAX
const unsigned int TIMER_FREQ = XPAR_AXI_TIMER_0_CLOCK_FREQ_HZ;
const int MAX_TIME = 10000; // max end time for a run

XTmrCtr timer;
XGpio gpio;

/*
 * Self-tests timer and GPIO
 *
 * If timer and GPIO self-tests works, returns 0
 * Else, returns -1
 */
int self_test() {
	int status;

	status = XTmrCtr_SelfTest(&timer, 0);
	if (status == XST_SUCCESS) XTmrCtr_SetOptions(&timer, 0, XTC_CASCADE_MODE_OPTION);
	else return -1;

	status = XGpio_SelfTest(&gpio);
	if (status == XST_SUCCESS) {
		XGpio_SetDataDirection(&gpio, LED_CHANNEL, 0b0000);
		XGpio_SetDataDirection(&gpio, TTL_CHANNEL, TTL_IO);
	} else return -1;

	return 0;
}

/*
 * If ERROR, returns -1
 * Else, returns 0
 */
int read_data_points(int *times_whole, int *times_decimal, int *positions, int n, int precision) {
	for (int i=0;i<n;i++) {
		char tw[10],td[10],p[10];
		scanf("%s",tw);
		times_whole[i] = atoi(tw);
		xil_printf("%d\n\r",times_whole[i]);
		scanf("%s",td);
		times_decimal[i] = atoi(td);
		xil_printf("%d\n\r",times_decimal[i]);
		scanf("%s",p);
		positions[i] = atoi(p);
		xil_printf("%d\n\r",positions[i]);

		if (times_whole[i]<0 || times_decimal[i]<0) {
			xil_printf("ERROR! Both parts of time must be non-negative!\n\r");
			return -1;
		}
		if (times_decimal[i]>=(int)pow(10,precision)) {
			xil_printf("ERROR! Number of decimal places is too large for the given precision\n\r");
			return -1;
		}
		if (times_whole[i]>MAX_TIME || (times_whole[i]==MAX_TIME && times_decimal[i]>0)) {
			xil_printf("ERROR! Must have 0<=t<%d\n\r", MAX_TIME);
		    return -1;
		} else if (i>0 && (times_whole[i]<times_whole[i-1] || (times_whole[i]==times_whole[i-1] && times_decimal[i]<times_decimal[i-1]))) { // have to always be moving forward in time
			xil_printf("ERROR! Must have t[i] > t[i-1]\n\r");
			return -1;
		}

		if (positions[i]<=0 || positions[i]>=(int)pow(2,PATTERN_LENGTH)) {
			xil_printf("ERROR! Must have 0<pos<%d\n\r", (int)pow(2,PATTERN_LENGTH));
		    return -1;
		}
	}

	return 0;
}

/*
 * Converts times to ticks
 * Ticks are uint32s
 * In theory there could be rounding errors, but I haven't seen it in any testing
 *
 * No returns
 */
void convert_times_to_ticks(unsigned int *ticks0, unsigned int *ticks1, double *times, unsigned int n) {
	for (int i=0;i<n;i++) {
		double ticks_total = times[i]*TIMER_FREQ;
		ticks1[i] = (unsigned int)(ticks_total/(MAX_TICKS0+1.0)+0.5);
		ticks_total -= ((double)ticks1[i])*(MAX_TICKS0+1.0);
		ticks0[i] = (unsigned int)(ticks_total+0.5);
	}
}

/*
 * Slow Control reads a run file, converts it to a format that is good for ARTY
 * ARTY reads the sanitized input from Slow Control
 *
 * If ERROR, returns -1
 * Else, returns 0
 */
int read_run(unsigned int *ticks0, unsigned int *ticks1, int *positions, int n) {
	/*
     * gets time precision
     * python's pyserial.write() doesn't seem to like working with floats
     * instead, get the whole part and decimal part of floats as two ints
     * but to parse the decimal part, ARTY needs to be told the precision == number of decimal places
	*/
	char prec[10];
	scanf("%s",prec);
    int precision = atoi(prec);
    xil_printf("%d\n\r",precision);
    if (precision<1 || precision>8) {
    	xil_printf("ERROR! Must have 1 <= precision <= 8\n\r");
    	return -1;
    }

    // read in data points
    int times_whole[n], times_decimal[n];
    int read_status = read_data_points(times_whole,times_decimal,positions,n,precision);
    if (read_status == -1) {
    	xil_printf("ERROR! Problem reading data points!\n\r");
    	return -1;
    }

	/**
	 * slow control will send either:
	 * 		"good" if ARTY echoed back the pattern correctly
	 * 		"bad" otherwise
	 */
	char check[10];
	scanf("%s",check);
	if (strcmp(check,"good")!=0) {
		xil_printf("Didn't hear \"good\"!\n\r");
		return -1;
	}

	/**
	 * convert times to ticks
	 * each half of the timer only goes up to UINT32_MAX, which at 200/3 MHz is ~= 50s
	 * the timer was set up in cascade mode, so when the first timer overflows it
	 * 		0. increments the second timer by 1
	 * 		1. resets first timer to 0
	 * 		2. continues counting on first timer
	 * 		ticks0 is first timer (~50s period)
	 * 		ticks1 is second timer (effectively infinite period, should never overflow)
	 */
	double times[n];
	for (int i=0;i<n;i++) times[i] = (double)times_whole[i] + times_decimal[i]*pow(10,-1*precision);
	convert_times_to_ticks(ticks0, ticks1, times, n);

	return 0;
}

/*
 * Runs a preset pattern
 * Makes TTL pins go high/low, listens for abort signal
 *
 * If timer of GPIO fails self-test, returns -1
 * If reaches end of run successfully, returns 0
 * If aborted, returns 1
 */
int run_pattern(unsigned int *ticks0, unsigned int *ticks1, int *positions, int n) {
	int i=0;

	if (self_test() == -1) {
		xil_printf("ERROR! Self-tests of timer and/or GPIO failed\n\r");
		return -1;
	}

	XTmrCtr_Reset(&timer,0);
	XTmrCtr_Start(&timer,0);

	while(i<n) {
		unsigned int read = XGpio_DiscreteRead(&gpio, TTL_CHANNEL);
		unsigned int t0 = XTmrCtr_GetValue(&timer, 0);
		unsigned int t1 = XTmrCtr_GetValue(&timer, 1);

	    if (t1>ticks1[i] || (t1==ticks1[i] && t0>=ticks0[i])) {
	    	XGpio_DiscreteWrite(&gpio, TTL_CHANNEL, (unsigned int)positions[i]);
	    	xil_printf("%u %u %u\n\r", t0, t1, positions[i]); // SLOW! takes ~10 ms
	    	i++;
	    }

	    // checks for abort
	    if (read & ABORT_PIN) {
			XGpio_DiscreteWrite(&gpio, TTL_CHANNEL, ABORT_PATTERN);
			xil_printf("%u %u %u\n\r", t0, t1, ABORT_PATTERN);
			return 1;
		}
	}

	XTmrCtr_Stop(&timer,0);
	return 0;
}

int main() {
	// sets up ARTY
	init_platform();
	XTmrCtr_Initialize(&timer, TIMER_ID);
	XGpio_Initialize(&gpio, GPIO_ID);

	// tests that ARTY is good to go
	if (self_test() == -1) return -1;

	// waits for any input, then starts
	char handshake[10];
	scanf("%s", handshake);
	xil_printf("ARTY has started!\n\r");
	xil_printf("%u %u\n\r", MAX_TICKS0, TIMER_FREQ);

	while (1) {
		char number[10];
		scanf("%s",number);
		int n = atoi(number);
		xil_printf("%d\n\r",n);

		if (n<1 || n>=100) {
			xil_printf("ERROR! A run must have 0 < number of data points < 100\n\r");
			continue;
		}

		unsigned int ticks0[n], ticks1[n];
		int positions[n];
		int read_status = read_run(ticks0, ticks1, positions, n);
		if (read_status == -1) {
			xil_printf("ERROR! Something went wrong reading the run!\n\r");
			continue;
		}

		int run_status = run_pattern(ticks0, ticks1, positions, n);
		if (run_status == -1) xil_printf("ERROR! Something went wrong running the pattern!\n\r");
	}

    cleanup_platform();
    return 0;
}
